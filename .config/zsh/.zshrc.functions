##
# Logger
logger::print() {
  local level="$1"
  shift

  case "$level" in
  ERROR | WARN)
    echo "[$(date +'%Y-%m-%dT%H:%M:%S%z')] [$level] $*" >&2
    ;;

  INFO | DEBUG)
    echo "[$(date +'%Y-%m-%dT%H:%M:%S%z')] [$level] $*"
    ;;
  esac
}
logger::error() {
  logger::print "ERROR" "$@"
}
logger::warn() {
  logger::print "WARN" "$@"
}
logger::info() {
  logger::print "INFO" "$@"
}
logger::debug() {
  logger::print "DEBUG" "$@"
}

##
# OS
os::is_darwin() {
  [ "$(uname -s)" = "Darwin" ]
}
os::is_ubuntu() {
  [ "$(uname -s)" = "Linux" ] && [ -f /etc/lsb-release ] && grep -q Ubuntu /etc/lsb-release
}
os::is_wsl() {
  [ -e "/proc/sys/fs/binfmt_misc/WSLInterop" ]
}

##
# Builder
builder::execute() {
  local cmd="$@"

  logger::info "${funcstack[1]}:"
  logger::info "  excute: $cmd"
  eval "$cmd" 2>&1 1>/dev/null
}

builder::package() {
  local -r name="$1"
  local -r cmd="apt-get install  --no-install-recommends -y $name"

  logger::info "${funcstack[1]}:"
  logger::info "  execute: $cmd"

  if os::is_darwin; then
    logger::warn "  Darwin is not supported"
    return
  fi
  eval $cmd 2>&1 1>/dev/null
}

builder::directory() {
  local -r directory_path="$1"
  logger::info "${funcstack[1]}:"
  logger::info "  execute: mkdir -p $directory_path"

  if [ -e "$directory_path" ]; then
    logger::warn "  $directory_path already exists"
    return
  fi

  mkdir -p "$directory_path" 2>&1 1>/dev/null
}

builder::link() {
  local -r source_path="$1"
  local -r destination_path="$2"

  logger::info "${funcstack[1]}:"
  logger::info "  execute: ln -sf $source_path $destination_path"
  if [ -e "$destination_path" ]; then
    logger::warn "  $destination_path already exists"
    return
  fi
  ln -sf "$source_path" "$destination_path" 2>&1 1>/dev/null
}

builder::touch() {
  local -r file_path="$1"

  logger::info "${funcstack[1]}:"
  logger::info "  execute: touch $file_path"

  if [ -e "$file_path" ]; then
    logger::warn "  $file_path already exists"
    return
  fi

  touch "$file_path" 2>&1 1>/dev/null
}

##
# Command
command::exist() {
  if [[ "$#" == 1 ]]; then
    local -i result=0
    which "$1" >/dev/null 2>&1 || result=1
    if ((result == 0)); then
      true
      return
    fi
  else
    logger::error 'too many arguments or less'
  fi
  false
}

command::clip() {
  if os::is_darwin; then
    pbcopy <"$1"
  elif os::is_wsl; then
    win32yank.exe -i <"$1"
  else
    logger::error "This function works only on macOS or WSL"
  fi
}

command::loop() {
  while :; do
    eval "$*"
    sleep 1
  done
}

# FYI: https://wiki.archlinux.org/index.php/Zsh#The_.22command_not_found.22_handler
command_not_found_handler() {
  local command="$1"
  echo "${LIGHT_RED}(;_;)${DEFAULT_COLOR} < Sorry, I didn't know ${PURPLE}${command}${DEFAULT_COLOR} command."
}

zsh::clean_zcompdump() {
  rm -f "$HOME"/.zcompdump*
  rm -f "$HOME"/.antigen/.zcompdump*
}

zsh::prompt::segment() {
  local bg fg
  [[ -n $1 ]] && bg="%K{$1}" || bg="%k"
  [[ -n $2 ]] && fg="%F{$2}" || fg="%f"
  echo -n "%{$bg%}%{$fg%} "
  [[ -n $3 ]] && echo -n "$3"
}
zsh::prompt::end() {
  echo -n "%{%f%}"
}
zsh::prompt::user() {
  zsh::prompt::segment none white "%n"
}
zsh::prompt::dir() {
  zsh::prompt::segment none white "%~"
}
zsh::prompt::git() {
  LANG=ja_JP.UTF-8 vcs_info
  zsh::prompt::segment none red "${vcs_info_msg_0_}%f"
}
zsh::prompt::exit_code() {
  zsh::prompt::segment none white "%?"
}

# Widget for zsh
widget::fzf::cdr() {
  cd "$(cdr -l | sed 's/^[^ ][^ ]*  *//' | fzf -1 | sed "s@~@$HOME@g")" || exit
  zle reset-prompt
}
zle -N widget::fzf::cdr

widget::fzf::workspace() {
  local -r _base_path=$HOME/Workspace
  local _directories
  if os::is_darwin; then
    _directories=$(find "$_base_path" -depth 2 -type d | sed "s#$_base_path/##g")
  else
    _directories=$(find "$_base_path" -mindepth 2 -maxdepth 2 -type d | sed "s#$_base_path/##g")
  fi
  local -r _path="$(echo "$_directories" | fzf -1 -0 --preview "bat --color=always $_base_path/{}/README.md 2>&1" | xargs -I{} echo $_base_path/{})"
  [[ -n "$_path" ]] && cd "$_path"
  zle reset-prompt
}
zle -N widget::fzf::workspace
